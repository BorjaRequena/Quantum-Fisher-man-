# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/randomized.ipynb (unless otherwise specified).

__all__ = ['random_unitary_circuits', 'randomized_measurement_overlap']

# Cell
import numpy as np

from qiskit.providers import Backend
from qiskit.utils import QuantumInstance
from qiskit.quantum_info import random_unitary
from qiskit.circuit import ParameterExpression
from qiskit.opflow import ListOp, StateFn, PrimitiveOp, TensoredOp, ExpectationBase, CircuitSampler, Zero

from typing import Optional, Union, Dict, List

# Cell
def random_unitary_circuits(
    n_rnd: int,
    n_qubits: int,
    d: Optional[int] = 2,
    local: Optional[bool] = True
) -> ListOp:
    "Samples `n_rnd` unitary random circuits with acting on `n_qubits`."
    def _random_circuit(n_qubits):
        if local:
            return TensoredOp([PrimitiveOp(random_unitary(d)) for _ in range(n_qubits)])
        else:
            return PrimitiveOp(random_unitary(d**n_qubits))
    return ListOp([_random_circuit(n_qubits) for _ in range(n_rnd)])

# Cell
def randomized_measurement_overlap(
    state0: StateFn,
    state1: Optional[Union[StateFn, ListOp]] = None,
    param_dict: Optional[Dict[ParameterExpression, List[float]]] = None,
    n_rnd: Optional[int] = None,
    local: Optional[bool] = True,
    expectation: Optional[ExpectationBase] = None,
    backend: Optional[Union[Backend, QuantumInstance]] = None
) -> np.ndarray:
    """Overlap computation between states using randomized measurements."""

    if state1 is not None and param_dict is not None:
        raise ValueError("randomized_measurement_overlap only accepts one optional input "
                         "either `state1` or `param_dict`."
                        )

    if param_dict is not None:
        state = state0.bind_parameters(param_dict)
    elif state1 is not None:
        state = ListOp([state0, *state1]) if isinstance(state1, ListOp) else ListOp([state0, state1])
    else:
        state = ListOp([state0])

    n_qubits = state0.num_qubits
    n_rnd = 2**(6 + n_qubits//2) if n_rnd is None else n_rnd
    U = random_unitary_circuits(n_rnd, n_qubits, local=local)
    observable = ~Zero @ U @ state

    if expectation is not None:
        observable = expectation.convert(observable)

    if backend is not None:
        observable = CircuitSampler(backend).convert(observable)

    rnd_measurements = np.abs(observable.eval())**2
    product_expectation = (rnd_measurements.T @ rnd_measurements)/rnd_measurements.shape[0]

    def _prefactor(counts):
        "Hilbert space size estimation from the measurement results."
        p = counts.mean(0)
        n_experiments = counts.shape[1]
        pmat = np.broadcast_to(p, (n_experiments, n_experiments))
        triu = np.triu(np.ones(n_experiments))
        tril = np.where(triu==0, 1, 0)
        return (1/pmat + triu)*(1/pmat.T + tril)

    overlap = _prefactor(rnd_measurements)*product_expectation - 1

    return overlap[0, 1:] if state1 is not None else overlap.squeeze()