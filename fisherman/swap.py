# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_swap.ipynb (unless otherwise specified).

__all__ = ['swap_test_overlap', 'swap_test_operator']

# Cell
import numpy as np
from .utils import sym_from_triu

from qiskit import BasicAer
from qiskit.utils import QuantumInstance
from qiskit.circuit import ParameterExpression
from qiskit.providers import Backend, BaseBackend
from qiskit import QuantumCircuit, ClassicalRegister
from qiskit.opflow import CircuitStateFn, CircuitOp

from collections.abc import Iterable
from typing import Optional, Union, Dict, List, Iterable

# Cell
def swap_test_overlap(
    state0: Union[QuantumCircuit, CircuitStateFn],
    state1: Optional[Union[QuantumCircuit, CircuitStateFn, Iterable[Union[QuantumCircuit, CircuitStateFn]]]] = None,
    param_dict: Optional[Dict[ParameterExpression, List[float]]] = None,
    backend: Optional[Union[Backend, QuantumInstance]] = None
) -> np.ndarray:
    """Returns overlap between states using swap test."""

    if state1 is not None and param_dict is not None:
        raise ValueError(
            "swap_test_overlap only accepts one optional input "
            "either `state1` or `param_dict`."
                        )

    backend = BasicAer.get_backend('qasm_simulator') if backend is None else backend
    qi = QuantumInstance(backend) if isinstance(backend, Backend) else backend
    if qi.is_statevector:
        raise ValueError("swap_test_overlap does not suport statevector simulator yet.")

    if isinstance(state0, QuantumCircuit):
        state0 = CircuitStateFn(state0)

    if state1 is not None:
        if not isinstance(state1, Iterable):
            state1 = [state1]
        state1 = [CircuitStateFn(s) if isinstance(s, QuantumCircuit) else s for s in state1]

    n_qubits = state0.num_qubits
    swap_op = swap_test_operator(n_qubits)
    ancilla = CircuitStateFn(QuantumCircuit(1))

    def _swap_circuit(s0, s1):
        circuit = (swap_op @ (s1 ^ s0 ^ ancilla)).primitive
        circuit.add_register(ClassicalRegister(1))
        circuit.measure(0, 0)
        return circuit

    if state1 is not None:
        circuits = [_swap_circuit(state0, s) for s in state1]
    elif param_dict is not None:
        states = state0.bind_parameters(param_dict)
        circuits = [_swap_circuit(s_i, s_j)
                    for i, s_i in enumerate(states) for s_j in states[i:]]
    else:
        circuits = [_swap_circuit(state0, state0)]

    counts = qi.execute(circuits).get_counts()
    if not isinstance(counts, list):
        counts = [counts]

    p0 = [c.get('0', 0)/sum(c.values()) for c in counts]
    overlaps = 2*np.array(p0) - 1

    return overlaps if param_dict is None else sym_from_triu(overlaps, len(states))

def swap_test_operator(n_qubits):
    swap_qc = QuantumCircuit(2*n_qubits+1)
    swap_qc.h(0)
    for q in range(n_qubits):
        swap_qc.cswap(0, q + 1, q + 1 + n_qubits)
    swap_qc.h(0)
    return CircuitOp(swap_qc)